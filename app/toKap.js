let getPixels = require("get-pixels")
let fs = require('fs');

const dim = 256 //hard coded, the pngs will always be 256x256x4, x/y/channels

// reference : http://opencpn.org/ocpn/kap_format

let toKap = function (metadata, pics) {
    let header = "";
    header += "VER/3.0\n";
    let paneName = "test";
    let paneNumber = "0";
    let paneWidth = 256;
    let paneHeight = 256;
    let dpi = 254;
    header += `BSB/NA=${paneName}\n`
    header += `    NU=${paneNumber},RA=${paneWidth},${paneHeight},DU=${dpi}\n`;

    let scale = "5000"
    let geodeticDatum = "WGS84"
    let projection = "MERCATOR"
    let projectionParameter = "0.00"
    let projectionInterval = "UNKNOWN"
    let sp = "UNKNOWN"
    let skewAngle = "0.0"
    let textAngle = "90.0"
    let depthUnit = "METERS"
    let soundingDatum = "MEAN SEA LEVEL"
    let dx = "" // resolution, distance (meters) covered by one pixel in X direction
    let dy = "" // resolution, distance covered by one pixel in Y direction
    header += `KNP/SC=${scale},GD=${geodeticDatum},PR=${projection},PP=${projectionParameter}\n`
    header += `    PI=${projectionInterval},SP=${sp},SK=${skewAngle},TA=${textAngle}\n`
    header += `    UN=${depthUnit},SD=${soundingDatum},DX=${dx},DY=${dy}\n`

    let sourceEdition = 2016; //number of paper chart
    let rasterEdition = 01;
    let chartEditionDate = 1 / 11 / 2016;
    header += `CED/SE=${sourceEdition},RE=${rasterEdition},ED=${chartEditionDate}\n`;

    header += "DTM/0,0\n" //DTM – Datum shift parameters - Datum's northing and easting in floating point seconds to go between chart datum and WGS84 (omitted or 0,0 for WGS84 charts)

    
    header += "CPH/0.00\n" //Phase shift value - optional

    // WPX – Polynomial longitude to x - optional. The Polynomials is an alternative to REF points for georeferencing. OpenCPN uses these polynomials if they are available. The existence of polynomials is a condition for using noaa:s chart reprojection tool.
    // PWX – Polynomial x to longitude - optional
    // WPY – Polynomial latitude to y - optional
    // PWY – Polynomial y to latitude - optional
    // eg: 
    // WPX/1,-782130.7428208,46307.7526455,81.3059558
    // WPY/1,5099061.4941929,157.4119364,-87678.8423412
    // PWX/1,16.787682449936700,0.000021591375907,0.000000023635910
    // PWY/1,58.186264063263100,0.000000037882540,-0.000011405323380

    // ERR – Error record –These should be present if polynomials are used. These ERR rows report the error at the REF points due to the usage of polynomials.
    // ERR/1,0,3,0.000035871747,0.000004273188
    // ERR/2,-1,2,0.000022610187,0.000019651756
    // ERR/3,1,-3,-0.000030985572,-0.000029228504
    // ERR/4,0,-3,-0.000027496363,0.000005303561

    // PLY - Border polygon record – coordinates of the panel within the raster image, given in chart datum lat/long. Any shape polygon
    // eg:
    // PLY/1,58.1862166767177,16.7880333336455
    // PLY/2,58.1792000100528,16.788031581456
    //
    // or:
    // PLY/1,66.306256,16.291060
    // PLY/2,66.306256,26.830100
    // PLY/3,59.546366,26.830100
    // PLY/4,59.546366,16.291060
    let nw = {lat:"60", lon:"10"}
    let se = {lat:"50", lon:"20"}
    header += `PLY/1,${nw.lat},${nw.lon}\n`
    header += `PLY/2,${nw.lat},${se.lon}\n`
    header += `PLY/3,${se.lat},${se.lon}\n`
    header += `PLY/4,${se.lat},${nw.lon}\n`

    //OST - Offset STrip image lines (number of image rows per entry in the index table) e.g. 1. Generated by imgkap.
    // eg: OST/1

    let colorMapDepth = "6" //calculate after creating image
    header += `IFM/${colorMapDepth}\n`

    let colors = [{ r: "255", g: "255", b: "255" }, { r: "126", g: "127", b: "127" }] //calculate after creating image
    for (col in colors) {
        header += `RGB/${col},${colors[col].r},${colors[col].g},${colors[col].b}\n`
    }

    let refPoints = [{ x: "0", y: "0", lat: "60", lon: "10" }, { x: "255", y: "255", lat: "50", lon: "20" }]
    for (ref in refPoints) {
        header += `REF/${ref},${refPoints[ref].x},${refPoints[ref].y},${refPoints[ref].lon},${refPoints[ref].lat}\n`
    }

    getPixels(pics, function (err, pixels) {
        if (err) {
            console.log("Bad image path")
            return
        }
        console.log("got pixels", pixels.shape.slice())

        let cnt = 0;
        let colors =[];
        let pixVals = new Map();
        for (y = 0; y < 256; y++) {
            for (x = 0; x < 256; x++) {
                let r = pixels.get(x, y, 0);
                let g = pixels.get(x, y, 1);
                let b = pixels.get(x, y, 2);
                let id = -1;
                let asStr = `${r}-${g}-${b}`
                if (pixVals.has(asStr)) {
                    id = pixvals.get(asStr)
                } else {
                    pixVals.add(asStr, ++cnt)
                    id = cnt;
                }
                //write pixel to body buffer
            }
        }

        for (var [key, value] of pixVals.entries()) {
            header +=
        }

    // The text header is terminated with a <Control-Z><NUL> sequence (ASCII characters 26 and 0). 
    header += String.fromCharCode(26)+String.fromCharCode(0) 

    //var str = 'Stack Overflow';
    var headBuf = new Buffer(header, 'ASCII');


        fs.writeFile("temp.kap", headBuf, (err) => {
            if (err) console.log("ERROR!", err)
            else console.log("wrote!")
        })
    })
}

module.exports.toKap = toKap;